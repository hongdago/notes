python_特殊方法
==================================
> 为了实现更好的可扩展性，Pyhton语言提供了大量的特殊方法，它们大致分为i以下几类：
* 特殊访问（Attribute Access)：这类特殊方法实现了对象的特殊访问，使用方式为object.attribute,即可以用来赋值，也可以在del语句中执行删除操作
* 可调用对象(Callables)：这个方法的适用对象为参数，就像python内部的len()函数。
* 集合(Collections)：这类方法提供了很多集合操作的功能。类似这类方法的使用有sequence[index],mapping[key]和some_set|another_set
* 数字(Numbers)：这类方法提供了大量的数字运算符和比较运算符。可以使用这些方法来扩展Python的数字部分。
* 上下文(Context)：这类函数通常使用with语句来实现上下文的管理。
* 迭代器(Iterator)：可是使用这类方法定义迭代器。

### __repr__()和__str__()
* 通常，str()方法表示的对象对用户更友好。这个方法是由对象的__str__()实现的
* repr()方法表示的通常会更技术化，这个方法是由__repr__()实现的
* print()函数会调用str()方法来生成输出的对象
* 字符串的format()函数也可以使用这些方法，当我们使用{!r}和{!s}格式时，实际上会分别调用__repr__()和__str__()方法

### __format__()方法
> string.format()和内置的format()函数都使用__format__()方法
* someobject.__format__(""):当应用程序中出现format(someobect)或'{0}'.format(someobject)时，会默认以这种方式调用__format__()
* someobject.__format__(specification):当应用程序中出现format(someobject,sperification)或者'{0:specification}'.format(someobject)时，会调用这种方式
>注意："{0!r}".format()和"{0!s}".format()并不会调用__format__()方法，它们会直接调用__repr__()和__str__()

### __hash__()方法
* 内置的hash()函数默认调用__hash__()方法
* object中默认的__hash__()方法的实现是基于对象内部的ID值生成哈希值，这个ID值可以通过id()函数查看
* 并非每个对象都需要提供一个哈希值，另外，对于不可变对象，可以显式的返回一个哈希值，这样这个对象就可以用作字典中的一个键或者集合中的一个成员
* 具有相同哈希值的对象互相不等是可以接受的
    >等价性比较有3个层次

    * 哈希值相等：这意味着两个对象可能相等。哈希值是判断两个对象有可能相等的快捷方式。如果哈希值不同，两个对象不可能相等，也不可能是同一个对象
    * 比较结果相等：这意味着两个对象的哈希值已经是相等的，这个比较用的是==运算符。如果比较结果相等，这两个对象有可能是同一个
    * ID相等:这意味着这两个对象是同一个。它们的哈希值相同，并且使用==的比较结果相等，这个比较使用的是is运算符


### __bool__()方法
内置的bool()函数调用__bool__()方法

### __bytes__()方法
bytes()函数调用__bytes__()方法，依据不同的参数，bytes()函数的行为也不同
* bytes(integer):返回一个不可变的字节对象，这个对象包含了给定数量的0x00值
* bytes(string):这个版本会将字符串编码为字节。其他的编码和异常处理的参数会定义编码的具体过程
* bytes(something):这个版本会调用something.__bytes__()创建字节对象，这里不需要编码或者异常处理参数
> object对象没有定义__bytes__()方法。这意味着所有的类在默认情况下都没有提供__bytes__()方法

### 比较运算符方法
* x < y  调用 x.__lt__(y)
* x <= y 调用x.__le__(y)
* x == y 调用x.__eq__(y)
* x != y 调用x.__ne__(y)
* x > y  调用x.__gt__(y)
* x >= y 调用x.__ge__(y)

### __new__()方法
* __new__()方法的一个用途是初始化不可变对象，__new__()方法中允许创建未初始化对象，这允许我们在__init__()方法被调用之前设置对象的属性
__new__()方法天生就是一个静态方法，即使没有使用@staticmethod修饰符，它也是静态的，它没有使用self变量，因为它的工作是创建最终会被赋值给self变量的对象,
方法签名为__new__(cls,*args,**kw), 当创建一个内置的不可变类型的子类时，不能重载__init__()方法，取而代之，我们必须通过重载__new__()方法在对象的创建过程中扩展基类的行为
* __new__()方法的另一种用途，作为元类型的一部分，主要是控制如何创建一个类


### 属性访问特殊方法
* __setattr__()函数用于属性的创建和赋值
* __getattr__()函数可以用来做两件事，如果属性已经赋值，__getattr__()则不会被调用，直接返回属性值即可，如果属性没有被赋值，那么将使用__getattr__()返回值
* __delattr__()函数用于删除属性
* __dir__()函数用于返回属性名称列表
* __getattribute__()方法提供了对属性更底层的一些操作，默认的实现逻辑先从内部的__dict__(或__slots__)中查找已有的属性，如果属性没有找到，则调用__getattr__()函数，如果值是一个修饰符，对修饰符进行处理，否则，返回当前值即可

### 创建修饰符
为了标识修饰符，修饰符必须实现以下3个方法的一个或多个
* Descriptor.__get__(self,instance,owner) -> object:在这个方法中，instance参数来自被访问对象的self变量。owner变量是拥有者类的对象。如果这个修饰符在类中被调用，instance参数默认值将为None
* Descriptor.__set__(self,instance,value): 在这个方法中，instance参数是被访问对象的self变量，而value参数为即将赋的新值
* Descriptor.__delete__(self,instance):在这个方法中，instance参数是被访问对象的self变量，并在这个方法中实现属性值的删除

### 集合的抽象基类
* Container基类要求子类实现__contains__()方法，这个特殊方法实现了in运算符
* Iterable基类要求子类实现__iter__()方法。for语句、生成器表达式和iter()函数都需要使用这个方法
* Sized基类要求子类实现__len__()方法。len()函数需要使用这个方法
* Hashable基类要求子类实现__hash__()方法。hash()函数需要使用这个方法，如果这个方法被实现，就意味着当前对象不可变
    >标准库的扩展

    * namedtuple()函数会允许创建包含可命名属性的tuple类。我们可以使用这个函数而不是额外完整地定义一个仅仅为属性值命名的类
    * deque()是一个双端队列，一个类似list的集合，但是可以在任何一段快速的进行增加和弹出操作。可以用这个类的其中一部分来创建常规的栈和队列
    * 可以使用ChainMap,而不是合并不同的映射。这是一个将多个映射连接起来的方法
    * OrderedDict是会保持所有元素原始插入顺序的一种映射
    * defaultDict是dict的一个子类，它内部使用一个工厂函数为所有没有值的键提供默认值
    * Counter也是dict的一个子类，它可以被用来统计对象，进而创建频率表
    * Heapq模块是包含一系列将堆队列(heap queue)的属性添加到一个现有list对象上的函数，堆队列的不变性是指堆上的所有元素按顺序存储，这样可以对堆队列进行升序的快速检索。如果在一个list结构上使用heapq方法，我们就不再需要显式地排序列表。这个方法可以带来很大的性能提升
    * array模块是一种对特定值的存储方式进行优化的序列

### 函数的属性列表
|属性 | 说明|
|-----|:----|
|__doc__|docstring或者None|
|__name__|函数的初始名称|
|__module__|函数所属的模块名称，或者None|
|__qualname__|函数的全名:__module__.__name__|
|__defaults__|默认的参数值，没有默认参数就是None|
|__kwdefaults__|只有关键字的参数的默认值|
|__code__|这个对象代表编译后的函数体|
|__dict__|函数属性的命名空间|
|__annotations__|参数的注释，包括“return"为返回值的注释|
|__globals__|函数所属模块的全局命名空间;这个属性用于解析只读的全局变量|
|__closure__|与函数中的自由变量(free variables)的绑定或者为None.它是只读的|

    


    
